// 26.5.3 anagram.cpp :
//допускаем след факты
//1 оба слова должны быть равны по кол-ву символов
//2 слова не должны быть составными(т.е. без пробелов)

#include <iostream>
#include <map>
#include <string>

bool isAnagram( std::string& s1, std::string& s2)       //функция проверки анаграмм 
{
    if (s1.length() != s2.length()) {                   //проверяем на равенство символов
        
        std::cout << "dannue slova ne anagram" << std::endl;
        return false;
        
    }

    std::map<char, int> charCounts;                     //объявляем мапу, хранящую символы и количество символов в качестве значения
   
        for (int i = 0; i < s1.length(); i++) {         //запускаем цикл по длине первого слова
            char c = s1[i];                             //создаем новую пременную и присваиваем ей [i]символ
            //далее магия......
            charCounts[c]++;        //ищем повторяющиеся символы и увеличиваем значение int на 1 если ключ уже есть
                                    //Если c нет на карте, к карте добавляется новая пара ключ-значение с ключом, 
                                    //установленным на c, и значением, равным 1.
                                    //Цикл продолжает выполняться до тех пор, пока не будут обработаны все символы в строке s1, 
                                    //а карта charCounts содержит количество всех символов в s1.
            //std::cout << "charCounts[" << i << "] = " << charCounts[c] << std::endl;     //test point
        }

            //еще магия
        for (int i = 0; i < s2.length(); i++){           //проверяем второе слово
        char c = s2[i];
        //std::cout << "c = " << c << std::endl;     //test point
        if (charCounts[c] == 0) {    //Эта строка проверяет, равно ли нулю количество символов c в мапе charCounts 
                                     //Если количество равно 0, это означает, что символ c отсутствует в s1 и, следовательно, 
                                     //строки s1 и s2 не могут быть анаграммами. 
                                        
            std::cout << "dannue slova ne anagram" << std::endl;
            return false;
        }
        //далее вообще жесть......
        else {                          //Если счетчик символа c в charCounts не равен 0, 
                                        //это означает, что символ присутствует как в s1, так и в s2. 
                                        //В этом случае функция уменьшает количество символов c в charCounts. 
                                        //Это гарантирует, что если в s2 есть несколько вхождений одного и того же символа, 
                                        //они будут правильно учтены, и функция сможет правильно определить, 
                                        //являются ли строки s1 и s2 анаграммами.Цикл продолжает выполняться до тех пор, 
                                        //пока не будут обработаны все символы строки s2.
                                        //Если к этому моменту функция еще не вернула false, это означает, 
                                        //что все символы в s2 присутствуют в s1 с правильными подсчетами, и, 
                                        //следовательно, s1 и s2 являются анаграммами.Функция возвращает истину.
            charCounts[c]--;
        }
    }
    std::cout << "dannue slova = anagram" << std::endl;
    return true;
}

int main()
{

    //std::map<char, int> charCounts;
    std::string s1;
    std::string s2;
    bool stop = false;
        while (!stop) {

    
            std::cout << "input slovo1 i slovo2(exit - stop proga)" << std::endl;
            std::cin >> s1 >> s2;
            if (s1 == "exit" || s2 == "exit") {
                stop = true;
                return 0;
            }else
            std::cout << isAnagram(s1, s2) << std::endl;  // ну это понятно



        }

    return 0;
}
